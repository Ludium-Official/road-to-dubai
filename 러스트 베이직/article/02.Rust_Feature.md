# Rust의 독특한 특징

Rust는 다른 프로그래밍 언어들과 차별화되는 특징들을 가지고 있다. 이런 특징들은 Rust를 설계할 때부터 의도적으로 반영한 것이다. 이런 점들을 이해하면 Rust를 배우는 데 도움이 될 것이다.

## 제로 코스트 추상화 (Zero-Cost Abstraction)

Rust의 핵심 원칙 중 하나가 "Zero-Cost Abstraction"이다. 이 개념은 원래 함수형 프로그래밍에서 나왔지만, 용어 자체는 C++에서 왔다. C++의 창시자가 다음과 같이 말했다:

"일반적으로 C++ 구현은 제로 오버헤드 원칙을 따른다: 사용하지 않는 것에 대해 비용을 지불하지 않는다. 더 나아가, 사용하는 것에 대해서는 직접 코딩한 것보다 더 나은 방법으로 구현할 수 없다."

이걸 풀어서 설명하면 이렇다:

1. 사용하지 않는 기능은 프로그램 성능에 영향을 주지 않는다.
2. 추상화된 코드의 성능이 수동으로 최적화한 코드와 동등하다.

예를 들어보겠다. Rust의 '수명(lifetime)' 개념은 이 원칙을 잘 보여준다. 수명은 포인터나 참조의 유효 기간을 컴파일 시점에 검사한다. 이렇게 하면 실행 중에 추가 검사를 할 필요가 없어진다.

반면에 JavaScript를 보자. JavaScript에서 객체를 변수에 할당하면, 실제로는 그 객체를 가리키는 참조를 저장하는 것이다. 변수를 복사해도 새 객체가 만들어지는 게 아니라, 같은 객체를 가리키는 참조가 하나 더 생기는 것이다. 그럼 이 참조들이 항상 유효한 객체를 가리키고 있다는 걸 어떻게 보장할까? JavaScript는 이걸 위해 실행 중에 참조 카운트(refcount)를 계속 추적한다. 이건 프로그래머가 원하든 원하지 않든 항상 발생하는 비용이다.

Rust는 이와 다르게 접근한다. 컴파일할 때 각 값이 언제 안전하게 삭제될 수 있는지 미리 계산해놓고, 실행 중에는 이런 검사를 하지 않는다. 이 '언제'를 결정하는 게 바로 수명 개념이다.

다른 예로, Java의 메서드 오버라이딩을 생각해보자. Java에서 오버라이드된 메서드를 호출하면, 실제 구현을 찾아서 그걸 실행해야 한다. 이걸 '동적 디스패치(dynamic dispatch)'라고 하는데, 이 과정에서 약간의 성능 저하가 발생한다. JVM이 최적화를 한다고 해도 이 비용을 완전히 없앨 순 없다.

Rust는 기본적으로 '정적 디스패치(static dispatch)'를 사용한다. 트레이트 객체(trait object)를 제외하면 모든 함수 호출이 어떤 구현을 사용할지 컴파일 때 결정된다. 이 방식은 Java보다 좀 더 경직된 설계를 만들 수 있지만, 실행 속도 면에서는 이점이 있다.

## 명시적 표현 선호

Rust는 모호한 것보다 명확한 걸 좋아한다. C의 integer promotion을 생각해보면, C에서는 정수 연산할 때 암묵적으로 `int`나 `unsigned int`로 변환해서 계산한다. 

Rust는 이런 암묵적인 변환을 싫어한다. JavaScript의 `1 + 'a'` 같은 암묵적 형변환이 가져올 수 있는 문제나 숨겨진 비용을 피하려고 한다. 

예를 들어, Rust 2018부터는 동적 디스패치를 위한 트레이트 객체를 사용할 때 `dyn` 키워드를 명시적으로 붙여야 한다. 타입 변환도 `as` 키워드나 `try_from` 메서드를 직접 사용해야 한다. 특히 `try_from`은 정보 손실이 있을 수 있을 때 권장되는 방법이다.

이런 접근 방식은 코드를 조금 더 장황하게 만들 수 있지만, 동작을 더 명확하게 이해할 수 있게 해준다.

reference: https://blog.cro.sh/posts/four-years-of-rust/
